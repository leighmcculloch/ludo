<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            padding: 20px;
            max-width: 800px;
            width: 100%;
        }

        .title {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
            font-weight: bold;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            gap: 2px;
            background: #333;
            padding: 10px;
            border-radius: 10px;
            aspect-ratio: 1;
            max-width: 600px;
            margin: 0 auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 2px 8px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .square {
            background: #f0f0f0;
            border: 1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .square:hover {
            background: #e0e0e0;
        }
        
        .square.non-playable:hover {
            background: transparent;
        }

        .square.home-red { background: #ffcccb; }
        .square.home-blue { background: #add8e6; }
        .square.home-green { background: #90ee90; }
        .square.home-yellow { background: #ffffe0; }
        
        .square.home-red.current-player-home { 
            background: #ffcccb; 
            border: 2px solid #e74c3c;
            animation: homeGlow 2s infinite;
        }
        .square.home-blue.current-player-home { 
            background: #add8e6; 
            border: 2px solid #3498db;
            animation: homeGlow 2s infinite;
        }
        .square.home-green.current-player-home { 
            background: #90ee90; 
            border: 2px solid #27ae60;
            animation: homeGlow 2s infinite;
        }
        .square.home-yellow.current-player-home { 
            background: #ffffe0; 
            border: 2px solid #f1c40f;
            animation: homeGlow 2s infinite;
        }
        
        @keyframes homeGlow {
            0% { background-color: rgba(255, 255, 255, 0.8); }
            50% { background-color: rgba(255, 255, 255, 0.9); }
            100% { background-color: rgba(255, 255, 255, 0.8); }
        }
        .square.safe { background: #ffffff; border: 2px solid #ccc; }
        .square.center { background: #ff69b4; }
        .square.path-red { background: #ff6b6b; }
        .square.path-blue { background: #4dabf7; }
        .square.path-green { background: #51cf66; }
        .square.path-yellow { background: #ffd43b; }
        .square.non-playable { 
            background: transparent; 
            border: none; 
            cursor: default;
        }

        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            cursor: pointer;
            position: absolute;
            top: 10%;
            left: 10%;
        }

        .piece:hover {
            transform: scale(1.1);
        }

        .piece.red { background: #e74c3c; }
        .piece.blue { background: #3498db; }
        .piece.green { background: #27ae60; }
        .piece.yellow { background: #f1c40f; }

        .piece.selectable {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .current-player {
            font-size: 1.8em;
            font-weight: bold;
            padding: 15px 25px;
            border-radius: 15px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            animation: currentPlayerPulse 2s infinite;
            border: 3px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        @keyframes currentPlayerPulse {
            0% { 
                transform: scale(1); 
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            }
            50% { 
                transform: scale(1.05); 
                box-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
            }
            100% { 
                transform: scale(1); 
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            }
        }

        .current-player.red { background: #e74c3c; }
        .current-player.blue { background: #3498db; }
        .current-player.green { background: #27ae60; }
        .current-player.yellow { background: #f1c40f; }

        .dice-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .dice {
            width: 60px;
            height: 60px;
            background: white;
            border: 2px solid #333;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2), 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .dice:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25), 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .dice.rolling {
            animation: roll 1s ease-in-out;
        }

        @keyframes roll {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(180deg); }
            75% { transform: rotate(270deg); }
            100% { transform: rotate(360deg); }
        }

        .roll-button {
            padding: 10px 20px;
            background: #2ecc71;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(46, 204, 113, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .roll-button:hover {
            background: #27ae60;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(46, 204, 113, 0.4), 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .roll-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .game-info {
            margin-top: 20px;
            text-align: center;
            font-size: 1.1em;
            color: #333;
        }

        .winner {
            font-size: 2em;
            font-weight: bold;
            text-align: center;
            margin-top: 20px;
            padding: 20px;
            border-radius: 10px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .winner.red { background: #e74c3c; }
        .winner.blue { background: #3498db; }
        .winner.green { background: #27ae60; }
        .winner.yellow { background: #f1c40f; }

        .reset-button {
            padding: 10px 20px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            margin-top: 20px;
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .reset-button:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(231, 76, 60, 0.4), 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .links-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            text-align: center;
            font-size: 0.9em;
            color: #666;
        }

        .links-section a {
            color: #3498db;
            text-decoration: none;
            margin: 0 10px;
            padding: 5px 10px;
            border-radius: 3px;
            transition: all 0.3s ease;
        }

        .links-section a:hover {
            background: #f8f9fa;
            color: #2980b9;
            text-decoration: underline;
        }

        /* Setup Screen Styles */
        .setup-screen {
            text-align: center;
            padding: 40px 20px;
        }

        .setup-screen h2 {
            color: #333;
            margin-bottom: 30px;
            font-size: 2em;
        }

        .player-selection {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .player-count-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .player-count-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4), 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .player-count-btn:active {
            transform: translateY(0);
        }

        .setup-info {
            color: #666;
            font-size: 1.1em;
            margin-top: 10px;
        }

        /* Inactive home areas */
        .inactive-home {
            opacity: 0.3;
            background: #999 !important;
        }

        /* Trail lines */
        .trail-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .trail-line {
            position: absolute;
            border-radius: 2px;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 5;
        }

        .trail-line.red { background: rgba(231, 76, 60, 0.8); }
        .trail-line.blue { background: rgba(52, 152, 219, 0.8); }
        .trail-line.green { background: rgba(39, 174, 96, 0.8); }
        .trail-line.yellow { background: rgba(241, 196, 15, 0.8); }

        /* Trail segments with different opacity based on age */
        .trail-segment-0 { opacity: 0.8; }
        .trail-segment-1 { opacity: 0.7; }
        .trail-segment-2 { opacity: 0.6; }
        .trail-segment-3 { opacity: 0.5; }
        .trail-segment-4 { opacity: 0.4; }
        .trail-segment-5 { opacity: 0.3; }
        .trail-segment-6 { opacity: 0.2; }
        .trail-segment-7 { opacity: 0.1; }
        .trail-segment-8 { opacity: 0.05; }
        .trail-segment-9 { opacity: 0.02; }

        @media (max-width: 768px) {
            .game-board {
                max-width: 90vw;
            }
            
            .title {
                font-size: 2em;
            }
            
            .controls {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="title">Ludo</h1>
        
        <!-- Player Selection Screen -->
        <div class="setup-screen" id="setupScreen">
            <h2>Choose Number of Players</h2>
            <div class="player-selection">
                <button class="player-count-btn" onclick="startGame(2)">2 Players</button>
                <button class="player-count-btn" onclick="startGame(3)">3 Players</button>
                <button class="player-count-btn" onclick="startGame(4)">4 Players</button>
            </div>
            <p class="setup-info">Select how many players will be playing this game.</p>
        </div>
        
        <!-- Game Screen -->
        <div class="game-screen" id="gameScreen" style="display: none;">
            <div class="game-board" id="gameBoard">
                <!-- Game board will be generated by JavaScript -->
            </div>
            
            <div class="controls">
                <div class="current-player" id="currentPlayer">Red Player's Turn</div>
                
                <div class="dice-container">
                    <div class="dice" id="dice">?</div>
                    <button class="roll-button" id="rollButton">Roll Dice</button>
                </div>
            </div>
            
            <div class="game-info" id="gameInfo">
                Roll the dice to start your turn!
            </div>
            
            <div id="winner" class="winner" style="display: none;"></div>
            
            <button class="reset-button" id="resetButton" onclick="resetGame()">New Game</button>
        </div>
        
        <div class="links-section">
            <a href="https://github.com/leighmcculloch/ludo" target="_blank">📂 View Source Code</a>
            <a href="https://en.wikipedia.org/wiki/Ludo" target="_blank">📖 Learn the Rules</a>
        </div>
    </div>

    <script>
        // Game state
        let currentPlayer = 0; // 0: Red, 1: Blue, 2: Green, 3: Yellow
        let diceValue = 0;
        let gameStarted = false;
        let gameEnded = false;
        let canRollDice = true;
        let consecutiveSixes = 0;
        let numberOfPlayers = 4; // Default to 4 players, can be changed
        
        const allPlayerColors = ['red', 'blue', 'green', 'yellow'];
        const allPlayerNames = ['Red', 'Blue', 'Green', 'Yellow'];
        
        // Dynamic arrays based on number of players
        let playerColors = [];
        let playerNames = [];
        
        // Board configuration
        const boardSize = 15;
        const pieces = {
            red: [{ id: 'r1', pos: null, home: true, trail: [] }, { id: 'r2', pos: null, home: true, trail: [] }, { id: 'r3', pos: null, home: true, trail: [] }, { id: 'r4', pos: null, home: true, trail: [] }],
            blue: [{ id: 'b1', pos: null, home: true, trail: [] }, { id: 'b2', pos: null, home: true, trail: [] }, { id: 'b3', pos: null, home: true, trail: [] }, { id: 'b4', pos: null, home: true, trail: [] }],
            green: [{ id: 'g1', pos: null, home: true, trail: [] }, { id: 'g2', pos: null, home: true, trail: [] }, { id: 'g3', pos: null, home: true, trail: [] }, { id: 'g4', pos: null, home: true, trail: [] }],
            yellow: [{ id: 'y1', pos: null, home: true, trail: [] }, { id: 'y2', pos: null, home: true, trail: [] }, { id: 'y3', pos: null, home: true, trail: [] }, { id: 'y4', pos: null, home: true, trail: [] }]
        };
        
        // Board path positions (clockwise around the board)
        const boardPath = [
            [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6], // Red starting area
            [5, 6], [4, 6], [3, 6], [2, 6], [1, 6], [0, 6], // Top side
            [0, 7], [0, 8], // Top corner
            [1, 8], [2, 8], [3, 8], [4, 8], [5, 8], [6, 8], // Blue starting area
            [6, 9], [6, 10], [6, 11], [6, 12], [6, 13], [6, 14], // Right side
            [7, 14], [8, 14], // Right corner
            [8, 13], [8, 12], [8, 11], [8, 10], [8, 9], [8, 8], // Green starting area
            [9, 8], [10, 8], [11, 8], [12, 8], [13, 8], [14, 8], // Bottom side
            [14, 7], [14, 6], // Bottom corner
            [13, 6], [12, 6], [11, 6], [10, 6], [9, 6], [8, 6], // Yellow starting area
            [8, 5], [8, 4], [8, 3], [8, 2], [8, 1], [8, 0], // Left side
            [7, 0], [6, 0] // Left corner back to start
        ];
        
        // Home paths (paths leading to center)
        const homePaths = {
            red: [[7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6]],
            blue: [[1, 7], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7]],
            green: [[7, 13], [7, 12], [7, 11], [7, 10], [7, 9], [7, 8]],
            yellow: [[13, 7], [12, 7], [11, 7], [10, 7], [9, 7], [8, 7]]
        };
        
        // Starting positions for each player
        const startPositions = {
            red: 1,
            blue: 14,
            green: 28,
            yellow: 42
        };
        
        // Home squares for each player
        const homeSquares = {
            red: [[1, 1], [1, 2], [2, 1], [2, 2]],
            blue: [[1, 12], [1, 13], [2, 12], [2, 13]],
            green: [[12, 12], [12, 13], [13, 12], [13, 13]],
            yellow: [[12, 1], [12, 2], [13, 1], [13, 2]]
        };
        
        // Safe squares (star positions)
        const safeSquares = [
            [6, 2], [2, 6], [6, 12], [12, 8], [8, 12], [12, 6], [8, 2], [2, 8]
        ];
        
        // Start game with selected number of players
        function startGame(playerCount) {
            numberOfPlayers = playerCount;
            
            // Set up player arrays based on selected count
            playerColors = allPlayerColors.slice(0, playerCount);
            playerNames = allPlayerNames.slice(0, playerCount);
            
            // Hide setup screen and show game screen
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            // Initialize the game
            initGame();
        }
        
        // Initialize the game
        function initGame() {
            createBoard();
            updateUI();
            setupEventListeners();
        }
        
        // Check if a square is playable (pieces can be placed on it)
        function isPlayableSquare(row, col) {
            // Home squares
            if (row >= 1 && row <= 2 && col >= 1 && col <= 2) return true; // Red home
            if (row >= 1 && row <= 2 && col >= 12 && col <= 13) return true; // Blue home
            if (row >= 12 && row <= 13 && col >= 12 && col <= 13) return true; // Green home
            if (row >= 12 && row <= 13 && col >= 1 && col <= 2) return true; // Yellow home
            
            // Center square
            if (row === 7 && col === 7) return true;
            
            // Board path squares
            if (boardPath.some(pos => pos[0] === row && pos[1] === col)) return true;
            
            // Home path squares
            if (homePaths.red.some(pos => pos[0] === row && pos[1] === col)) return true;
            if (homePaths.blue.some(pos => pos[0] === row && pos[1] === col)) return true;
            if (homePaths.green.some(pos => pos[0] === row && pos[1] === col)) return true;
            if (homePaths.yellow.some(pos => pos[0] === row && pos[1] === col)) return true;
            
            return false;
        }
        
        // Create the game board
        function createBoard() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';
            
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    const square = document.createElement('div');
                    square.className = 'square';
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.id = `square-${row}-${col}`;
                    
                    // Check if this square is playable
                    if (!isPlayableSquare(row, col)) {
                        square.classList.add('non-playable');
                    }
                    
                    // Add special square classes
                    if (row >= 1 && row <= 2 && col >= 1 && col <= 2) {
                        square.classList.add('home-red');
                        // Hide home area if player is not active
                        if (!playerColors.includes('red')) {
                            square.classList.add('inactive-home');
                        }
                    } else if (row >= 1 && row <= 2 && col >= 12 && col <= 13) {
                        square.classList.add('home-blue');
                        // Hide home area if player is not active
                        if (!playerColors.includes('blue')) {
                            square.classList.add('inactive-home');
                        }
                    } else if (row >= 12 && row <= 13 && col >= 12 && col <= 13) {
                        square.classList.add('home-green');
                        // Hide home area if player is not active
                        if (!playerColors.includes('green')) {
                            square.classList.add('inactive-home');
                        }
                    } else if (row >= 12 && row <= 13 && col >= 1 && col <= 2) {
                        square.classList.add('home-yellow');
                        // Hide home area if player is not active
                        if (!playerColors.includes('yellow')) {
                            square.classList.add('inactive-home');
                        }
                    } else if (row === 7 && col === 7) {
                        square.classList.add('center');
                    } else if (safeSquares.some(pos => pos[0] === row && pos[1] === col)) {
                        square.classList.add('safe');
                    }
                    
                    // Add home path colors
                    if (homePaths.red.some(pos => pos[0] === row && pos[1] === col)) {
                        square.classList.add('path-red');
                    } else if (homePaths.blue.some(pos => pos[0] === row && pos[1] === col)) {
                        square.classList.add('path-blue');
                    } else if (homePaths.green.some(pos => pos[0] === row && pos[1] === col)) {
                        square.classList.add('path-green');
                    } else if (homePaths.yellow.some(pos => pos[0] === row && pos[1] === col)) {
                        square.classList.add('path-yellow');
                    }
                    
                    board.appendChild(square);
                }
            }
            
            // Add trail container for drawing piece trails
            const trailContainer = document.createElement('div');
            trailContainer.className = 'trail-container';
            trailContainer.id = 'trailContainer';
            board.appendChild(trailContainer);
            
            // Place initial pieces
            placePieces();
        }
        
        // Place pieces on the board
        function placePieces() {
            // Clear existing pieces
            document.querySelectorAll('.piece').forEach(piece => piece.remove());
            
            // Place pieces for each player
            Object.keys(pieces).forEach(color => {
                pieces[color].forEach((piece, index) => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = `piece ${color}`;
                    pieceElement.textContent = index + 1;
                    pieceElement.dataset.color = color;
                    pieceElement.dataset.pieceId = piece.id;
                    
                    if (piece.home) {
                        // Place in home area
                        const homePos = homeSquares[color][index];
                        const square = document.getElementById(`square-${homePos[0]}-${homePos[1]}`);
                        square.appendChild(pieceElement);
                    } else if (piece.pos !== null) {
                        // Place on board
                        const pos = getSquarePosition(color, piece.pos);
                        if (pos) {
                            const square = document.getElementById(`square-${pos[0]}-${pos[1]}`);
                            
                            // Check how many pieces are already in this square
                            const existingPieces = square.querySelectorAll('.piece');
                            const pieceCount = existingPieces.length;
                            
                            // Apply offset based on piece count to make multiple pieces visible
                            if (pieceCount > 0) {
                                const offsetX = (pieceCount % 2) * 15; // Horizontal offset
                                const offsetY = Math.floor(pieceCount / 2) * 15; // Vertical offset
                                pieceElement.style.left = `${10 + offsetX}%`;
                                pieceElement.style.top = `${10 + offsetY}%`;
                            }
                            
                            square.appendChild(pieceElement);
                        }
                    }
                    
                    // Add click event listener
                    pieceElement.addEventListener('click', () => selectPiece(color, piece.id));
                });
            });
        }
        
        // Get square position for a piece
        function getSquarePosition(color, position) {
            if (position === 'center') {
                return [7, 7];
            }
            
            if (position >= 0 && position < boardPath.length) {
                return boardPath[position];
            }
            
            // Check if it's in home path
            const homePathIndex = position - boardPath.length;
            if (homePathIndex >= 0 && homePathIndex < homePaths[color].length) {
                return homePaths[color][homePathIndex];
            }
            
            return null;
        }
        
        // Draw trails for all pieces
        function drawTrails() {
            const trailContainer = document.getElementById('trailContainer');
            if (!trailContainer) return;
            
            console.log('Drawing trails...');
            
            // Clear existing trails
            trailContainer.innerHTML = '';
            
            // Draw trails for each player's pieces
            Object.keys(pieces).forEach(color => {
                pieces[color].forEach(piece => {
                    if (piece.trail && piece.trail.length > 1) {
                        console.log(`Drawing trail for piece ${piece.id} with ${piece.trail.length} positions`);
                        drawPieceTrail(piece, color);
                    }
                });
            });
        }
        
        // Draw trail for a specific piece
        function drawPieceTrail(piece, color) {
            const trailContainer = document.getElementById('trailContainer');
            if (!trailContainer || !piece.trail || piece.trail.length < 2) return;
            
            console.log(`Drawing trail for piece ${piece.id} of color ${color}`);
            
            const maxTrailLength = 10; // Maximum number of trail segments to show
            const recentTrail = piece.trail.slice(-maxTrailLength);
            
            // Draw lines connecting each position in the trail
            for (let i = 0; i < recentTrail.length - 1; i++) {
                const fromPos = getSquarePosition(color, recentTrail[i]);
                const toPos = getSquarePosition(color, recentTrail[i + 1]);
                
                console.log(`Trail segment ${i}: from ${recentTrail[i]} to ${recentTrail[i + 1]}`);
                console.log(`Positions: from [${fromPos}] to [${toPos}]`);
                
                if (fromPos && toPos) {
                    const line = createTrailLine(fromPos, toPos, color, recentTrail.length - 1 - i);
                    trailContainer.appendChild(line);
                    console.log(`Created trail line element`);
                }
            }
        }
        
        // Create a trail line element between two positions
        function createTrailLine(fromPos, toPos, color, age) {
            const line = document.createElement('div');
            line.className = `trail-line ${color} trail-segment-${Math.min(age, 9)}`;
            
            // Calculate line position and rotation
            const board = document.getElementById('gameBoard');
            const boardRect = board.getBoundingClientRect();
            const gridGap = 2; // From CSS gap: 2px
            const padding = 10; // From CSS padding: 10px
            
            // Calculate square size accounting for gaps
            const totalGapWidth = gridGap * (boardSize - 1);
            const availableWidth = boardRect.width - (padding * 2) - totalGapWidth;
            const squareSize = availableWidth / boardSize;
            
            // Calculate positions relative to the board container
            const fromX = fromPos[1] * (squareSize + gridGap) + squareSize / 2 + padding;
            const fromY = fromPos[0] * (squareSize + gridGap) + squareSize / 2 + padding;
            const toX = toPos[1] * (squareSize + gridGap) + squareSize / 2 + padding;
            const toY = toPos[0] * (squareSize + gridGap) + squareSize / 2 + padding;
            
            const deltaX = toX - fromX;
            const deltaY = toY - fromY;
            const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
            
            line.style.left = fromX + 'px';
            line.style.top = fromY + 'px';
            line.style.width = length + 'px';
            line.style.height = '4px'; // Make it a bit thicker for visibility
            line.style.transformOrigin = '0 50%';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.backgroundColor = color === 'red' ? 'rgba(231, 76, 60, 0.8)' : 
                                        color === 'blue' ? 'rgba(52, 152, 219, 0.8)' :
                                        color === 'green' ? 'rgba(39, 174, 96, 0.8)' :
                                        'rgba(241, 196, 15, 0.8)';
            
            console.log(`Trail line: from (${fromX}, ${fromY}) to (${toX}, ${toY}), length: ${length}, angle: ${angle}, squareSize: ${squareSize}`);
            
            return line;
        }
        
        // Update trail for a piece when it moves
        function updatePieceTrail(piece, newPos) {
            if (!piece.trail) {
                piece.trail = [];
            }
            
            // Don't add duplicate positions
            if (piece.trail.length === 0 || piece.trail[piece.trail.length - 1] !== newPos) {
                piece.trail.push(newPos);
                console.log(`Updated trail for piece ${piece.id}: [${piece.trail.join(', ')}]`);
                
                // Limit trail length to prevent memory issues
                const maxTrailLength = 20;
                if (piece.trail.length > maxTrailLength) {
                    piece.trail = piece.trail.slice(-maxTrailLength);
                }
            }
        }
        
        // Clear trail for a piece (when captured or reset)
        function clearPieceTrail(piece) {
            if (piece.trail) {
                piece.trail = [];
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('rollButton').addEventListener('click', rollDice);
            document.getElementById('resetButton').addEventListener('click', resetGame);
        }
        
        // Roll dice
        function rollDice() {
            if (!canRollDice || gameEnded) return;
            
            const dice = document.getElementById('dice');
            const rollButton = document.getElementById('rollButton');
            
            dice.classList.add('rolling');
            rollButton.disabled = true;
            canRollDice = false;
            
            setTimeout(() => {
                diceValue = Math.floor(Math.random() * 6) + 1;
                dice.textContent = diceValue;
                dice.classList.remove('rolling');
                
                if (diceValue === 6) {
                    consecutiveSixes++;
                    if (consecutiveSixes >= 3) {
                        // Three consecutive sixes, lose turn
                        document.getElementById('gameInfo').textContent = 'Three sixes in a row! Turn lost.';
                        consecutiveSixes = 0;
                        setTimeout(() => {
                            nextPlayer();
                        }, 1500);
                        return;
                    }
                } else {
                    consecutiveSixes = 0;
                }
                
                const movablePieces = getMovablePieces();
                if (movablePieces.length === 0) {
                    document.getElementById('gameInfo').textContent = 'No valid moves available!';
                    setTimeout(() => {
                        if (diceValue !== 6) {
                            nextPlayer();
                        } else {
                            canRollDice = true;
                            rollButton.disabled = false;
                            document.getElementById('gameInfo').textContent = 'Auto-rolling again (you got a 6)...';
                            
                            // Auto-roll again after getting a 6
                            setTimeout(() => {
                                if (canRollDice && !gameEnded) {
                                    rollDice();
                                }
                            }, 1000);
                        }
                    }, 1500);
                } else if (movablePieces.length === 1) {
                    // Auto-move when only one piece can move
                    document.getElementById('gameInfo').textContent = 'Auto-moving the only available piece...';
                    setTimeout(() => {
                        movePiece(movablePieces[0].color, movablePieces[0].id);
                    }, 1000);
                } else {
                    // Check if this is the special case: rolled 6 with no pieces on board
                    const color = playerColors[currentPlayer];
                    const piecesOnBoard = pieces[color].filter(piece => !piece.home && piece.pos !== 'center');
                    
                    if (diceValue === 6 && piecesOnBoard.length === 0) {
                        // Player rolled 6 and has no pieces on board - auto-select first piece
                        document.getElementById('gameInfo').textContent = 'Auto-moving first piece out of home...';
                        setTimeout(() => {
                            movePiece(movablePieces[0].color, movablePieces[0].id);
                        }, 1000);
                    } else {
                        // Multiple pieces can move, let player choose
                        document.getElementById('gameInfo').textContent = 'Select a piece to move!';
                        highlightMovablePieces(movablePieces);
                    }
                }
            }, 1000);
        }
        
        // Get movable pieces for current player
        function getMovablePieces() {
            const color = playerColors[currentPlayer];
            const movablePieces = [];
            
            pieces[color].forEach(piece => {
                if (canMovePiece(color, piece.id)) {
                    movablePieces.push({ color, id: piece.id });
                }
            });
            
            return movablePieces;
        }
        
        // Check if a piece can move
        function canMovePiece(color, pieceId) {
            const piece = pieces[color].find(p => p.id === pieceId);
            if (!piece) return false;
            
            if (piece.home) {
                // Can only move out of home with a 6
                if (diceValue !== 6) return false;
                
                return true;
            }
            
            if (piece.pos === 'center') {
                // Already at center, can't move
                return false;
            }
            
            // Check if the move would be valid
            const newPos = calculateNewPosition(color, piece.pos, diceValue);
            return newPos !== null;
        }
        
        // Calculate new position after move
        function calculateNewPosition(color, currentPos, moves) {
            if (currentPos === null) {
                // Moving from home
                if (moves === 6) {
                    return startPositions[color];
                }
                return null;
            }
            
            if (currentPos === 'center') {
                return null; // Can't move from center
            }
            
            let newPos = currentPos + moves;
            
            // Check if should enter home path
            // A piece can only enter home path if it's at the correct entrance position
            const homePathEntrancePos = (startPositions[color] + 51) % boardPath.length;
            
            // Check if the piece is at the home entrance position
            if (currentPos === homePathEntrancePos) {
                // Piece is at home entrance, move into home path
                const homePathIndex = moves - 1; // First move takes us to the first home path position
                if (homePathIndex < homePaths[color].length) {
                    return boardPath.length + homePathIndex;
                } else if (homePathIndex === homePaths[color].length) {
                    return 'center';
                } else {
                    return null; // Overshoot
                }
            }
            
            // Handle normal board movement with wrapping
            if (newPos >= boardPath.length) {
                newPos = newPos % boardPath.length;
            }
            
            return newPos;
        }
        
        // Highlight movable pieces
        function highlightMovablePieces(movablePieces) {
            // Clear existing highlights
            document.querySelectorAll('.piece').forEach(piece => {
                piece.classList.remove('selectable');
            });
            
            // Highlight movable pieces
            movablePieces.forEach(({ color, id }) => {
                const pieceElement = document.querySelector(`[data-piece-id="${id}"]`);
                if (pieceElement) {
                    pieceElement.classList.add('selectable');
                }
            });
        }
        
        // Select piece to move
        function selectPiece(color, pieceId) {
            if (color !== playerColors[currentPlayer] || !canMovePiece(color, pieceId)) {
                return;
            }
            
            // Clear all piece animations first to ensure clean state
            document.querySelectorAll('.piece').forEach(piece => {
                piece.style.animation = 'none';
                piece.classList.remove('selectable');
            });
            
            // Add delay to ensure DOM is ready for animation
            setTimeout(() => {
                movePiece(color, pieceId);
            }, 300);
        }
        
        // Animate piece movement
        function animatePieceMovement(color, pieceId, fromPos, toPos, callback) {
            const pieceElement = document.querySelector(`[data-piece-id="${pieceId}"]`);
            if (!pieceElement) {
                callback();
                return;
            }
            
            // Clear any existing transitions, animations, and CSS effects to ensure clean state
            pieceElement.style.transition = 'none';
            pieceElement.style.transform = '';
            pieceElement.style.animation = 'none';
            pieceElement.style.zIndex = '';
            pieceElement.classList.remove('selectable');
            
            // Force a reflow to ensure all style changes are applied
            pieceElement.offsetHeight;
            
            // Wait a moment to ensure the DOM is fully settled
            setTimeout(() => {
                // Get the destination square position
                let destinationSquare;
                if (toPos === 'center') {
                    destinationSquare = document.getElementById('square-7-7');
                } else if (toPos === null) {
                    // Moving to home - find the appropriate home square
                    const homePositions = homeSquares[color];
                    const availableHomePos = homePositions.find(pos => {
                        const square = document.getElementById(`square-${pos[0]}-${pos[1]}`);
                        return !square.querySelector('.piece');
                    });
                    if (availableHomePos) {
                        destinationSquare = document.getElementById(`square-${availableHomePos[0]}-${availableHomePos[1]}`);
                    }
                } else if (typeof toPos === 'number') {
                    const squarePos = getSquarePosition(color, toPos);
                    if (squarePos) {
                        destinationSquare = document.getElementById(`square-${squarePos[0]}-${squarePos[1]}`);
                    }
                }
                
                if (!destinationSquare) {
                    // If we can't find destination, just call callback immediately
                    callback();
                    return;
                }
                
                // Get current and destination positions
                const currentRect = pieceElement.getBoundingClientRect();
                const destRect = destinationSquare.getBoundingClientRect();
                
                // Calculate the translation needed
                const deltaX = destRect.left - currentRect.left;
                const deltaY = destRect.top - currentRect.top;
                
                // Only animate if there's actual movement
                if (Math.abs(deltaX) < 1 && Math.abs(deltaY) < 1) {
                    callback();
                    return;
                }
                
                // Add animation styles
                pieceElement.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                pieceElement.style.transition = 'transform 0.6s ease-in-out';
                pieceElement.style.zIndex = '1000';
                
                // After animation completes, reset and update game state
                setTimeout(() => {
                    pieceElement.style.transform = '';
                    pieceElement.style.transition = '';
                    pieceElement.style.zIndex = '';
                    pieceElement.style.animation = '';
                    callback();
                }, 600);
            }, 50);
        }
        
        // Move piece
        function movePiece(color, pieceId) {
            const piece = pieces[color].find(p => p.id === pieceId);
            if (!piece) return;
            
            const newPos = calculateNewPosition(color, piece.pos, diceValue);
            if (newPos === null) return;
            
            // Store original position for animation
            const originalPos = piece.pos;
            
            // Start the animation
            animatePieceMovement(color, pieceId, originalPos, newPos, () => {
                // This callback runs after animation completes
                
                // Check for captures
                if (newPos !== 'center' && typeof newPos === 'number') {
                    const squarePos = getSquarePosition(color, newPos);
                    if (squarePos) {
                        const square = document.getElementById(`square-${squarePos[0]}-${squarePos[1]}`);
                        const existingPiece = square.querySelector('.piece');
                        if (existingPiece && existingPiece.dataset.color !== color) {
                            // Capture opponent piece
                            const capturedColor = existingPiece.dataset.color;
                            const capturedPieceId = existingPiece.dataset.pieceId;
                            const capturedPiece = pieces[capturedColor].find(p => p.id === capturedPieceId);
                            if (capturedPiece) {
                                capturedPiece.pos = null;
                                capturedPiece.home = true;
                                // Clear the captured piece's trail
                                clearPieceTrail(capturedPiece);
                            }
                            existingPiece.remove();
                        }
                    }
                }
                
                // Update piece position
                piece.pos = newPos;
                piece.home = false;
                
                // Update the piece's trail
                if (originalPos !== null) {
                    // Moving from a board position - add the original position to trail
                    updatePieceTrail(piece, originalPos);
                } else {
                    // Moving from home - start new trail
                    clearPieceTrail(piece);
                }
                updatePieceTrail(piece, newPos);
                
                // Re-place pieces
                placePieces();
                
                // Draw trails after placing pieces
                drawTrails();
                
                // Check for win
                if (checkWin(color)) {
                    endGame(color);
                    return;
                }
                
                // Clear highlights
                document.querySelectorAll('.piece').forEach(piece => {
                    piece.classList.remove('selectable');
                });
                
                // Check if player gets another turn (rolled 6)
                if (diceValue === 6) {
                    canRollDice = true;
                    document.getElementById('rollButton').disabled = false;
                    document.getElementById('gameInfo').textContent = 'Auto-rolling again (you got a 6)...';
                    
                    // Auto-roll again after getting a 6
                    setTimeout(() => {
                        if (canRollDice && !gameEnded) {
                            rollDice();
                        }
                    }, 1000);
                } else {
                    nextPlayer();
                }
            });
        }
        
        // Check if player has won
        function checkWin(color) {
            return pieces[color].every(piece => piece.pos === 'center');
        }
        
        // End game
        function endGame(winnerColor) {
            gameEnded = true;
            const winnerDiv = document.getElementById('winner');
            const colorName = playerNames[playerColors.indexOf(winnerColor)];
            winnerDiv.textContent = `🎉 ${colorName} Player Wins! 🎉`;
            winnerDiv.className = `winner ${winnerColor}`;
            winnerDiv.style.display = 'block';
            
            document.getElementById('rollButton').disabled = true;
            document.getElementById('gameInfo').textContent = 'Game Over!';
        }
        
        // Next player
        function nextPlayer() {
            currentPlayer = (currentPlayer + 1) % numberOfPlayers;
            consecutiveSixes = 0;
            updateUI();
        }
        
        // Update UI
        function updateUI() {
            const currentPlayerDiv = document.getElementById('currentPlayer');
            const color = playerColors[currentPlayer];
            const name = playerNames[currentPlayer];
            
            currentPlayerDiv.textContent = `${name} Player's Turn`;
            currentPlayerDiv.className = `current-player ${color}`;
            
            // Remove previous home highlights
            document.querySelectorAll('.current-player-home').forEach(square => {
                square.classList.remove('current-player-home');
            });
            
            // Add current player home highlight
            const homeClass = `home-${color}`;
            document.querySelectorAll(`.${homeClass}`).forEach(square => {
                square.classList.add('current-player-home');
            });
            
            if (!gameEnded) {
                canRollDice = true;
                document.getElementById('rollButton').disabled = false;
                document.getElementById('gameInfo').textContent = 'Auto-rolling dice...';
                
                // Auto-roll dice after a short delay
                setTimeout(() => {
                    if (canRollDice && !gameEnded) {
                        rollDice();
                    }
                }, 1000);
            }
            
            // Reset dice
            document.getElementById('dice').textContent = '?';
        }
        
        // Reset game
        function resetGame() {
            // Reset game state
            currentPlayer = 0;
            diceValue = 0;
            gameStarted = false;
            gameEnded = false;
            canRollDice = true;
            consecutiveSixes = 0;
            
            // Reset pieces
            Object.keys(pieces).forEach(color => {
                pieces[color].forEach(piece => {
                    piece.pos = null;
                    piece.home = true;
                    // Clear trails
                    clearPieceTrail(piece);
                });
            });
            
            // Hide winner
            document.getElementById('winner').style.display = 'none';
            
            // Remove home highlights
            document.querySelectorAll('.current-player-home').forEach(square => {
                square.classList.remove('current-player-home');
            });
            
            // Show setup screen and hide game screen
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('setupScreen').style.display = 'block';
        }
        
        // Initialize setup screen on page load
        window.addEventListener('load', () => {
            // Show setup screen on page load
            document.getElementById('setupScreen').style.display = 'block';
            document.getElementById('gameScreen').style.display = 'none';
        });
    </script>
</body>
</html>