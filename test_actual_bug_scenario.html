<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Actual Bug Scenario Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 800px;
            margin: 0 auto;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        }
        .test-pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .analysis {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #6c757d;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>Actual Bug Scenario Analysis</h1>
        
        <div class="analysis">
            <h3>üîç Real Bug Investigation</h3>
            <p>Let's analyze when the original bug would actually manifest:</p>
            <ul>
                <li><strong>Board length:</strong> 56 positions (0-55)</li>
                <li><strong>Green start:</strong> 28</li>
                <li><strong>Buggy home path start:</strong> 28 + 51 = 79</li>
                <li><strong>Issue:</strong> Since 79 > 56, the buggy condition <code>newPos >= 79</code> would never be met!</li>
            </ul>
            <p>The real bug was likely in the wrapping logic when pieces go beyond the board length.</p>
        </div>

        <div id="testResults"></div>
    </div>

    <script>
        const boardPath = [
            [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6], // Red starting area
            [5, 6], [4, 6], [3, 6], [2, 6], [1, 6], [0, 6], // Top side
            [0, 7], [0, 8], // Top corner
            [1, 8], [2, 8], [3, 8], [4, 8], [5, 8], [6, 8], // Blue starting area
            [6, 9], [6, 10], [6, 11], [6, 12], [6, 13], [6, 14], // Right side
            [7, 14], [8, 14], // Right corner
            [8, 13], [8, 12], [8, 11], [8, 10], [8, 9], [8, 8], // Green starting area
            [9, 8], [10, 8], [11, 8], [12, 8], [13, 8], [14, 8], // Bottom side
            [14, 7], [14, 6], // Bottom corner
            [13, 6], [12, 6], [11, 6], [10, 6], [9, 6], [8, 6], // Yellow starting area
            [8, 5], [8, 4], [8, 3], [8, 2], [8, 1], [8, 0], // Left side
            [7, 0], [6, 0] // Left corner back to start
        ];

        const homePaths = {
            red: [[7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6]],
            blue: [[1, 7], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7]],
            green: [[7, 13], [7, 12], [7, 11], [7, 10], [7, 9], [7, 8]],
            yellow: [[13, 7], [12, 7], [11, 7], [10, 7], [9, 7], [8, 7]]
        };

        const startPositions = {
            red: 1,
            blue: 14,
            green: 28,
            yellow: 42
        };

        // Original buggy version from the code
        function calculateNewPositionBuggy(color, currentPos, moves) {
            if (currentPos === null) {
                if (moves === 6) {
                    return startPositions[color];
                }
                return null;
            }
            
            if (currentPos === 'center') {
                return null;
            }
            
            let newPos = currentPos + moves;
            
            // Check if should enter home path
            const homePathStart = startPositions[color] + 51;
            if (currentPos < homePathStart && newPos >= homePathStart) {
                // Enter home path
                const homePathIndex = newPos - homePathStart;
                if (homePathIndex < homePaths[color].length) {
                    return boardPath.length + homePathIndex;
                } else if (homePathIndex === homePaths[color].length) {
                    return 'center';
                } else {
                    return null; // Overshoot
                }
            }
            
            // Normal board movement
            if (newPos >= boardPath.length) {
                // This is where the bug was - handling wrapping
                const homePathIndex = newPos - boardPath.length;
                if (homePathIndex < homePaths[color].length) {
                    return boardPath.length + homePathIndex;
                } else if (homePathIndex === homePaths[color].length) {
                    return 'center';
                } else {
                    return null; // Overshoot
                }
            }
            
            return newPos % boardPath.length;
        }

        // Fixed version
        function calculateNewPosition(color, currentPos, moves) {
            if (currentPos === null) {
                if (moves === 6) {
                    return startPositions[color];
                }
                return null;
            }
            
            if (currentPos === 'center') {
                return null;
            }
            
            let newPos = currentPos + moves;
            
            // Check if should enter home path
            const homePathEntrancePos = (startPositions[color] + 51) % boardPath.length;
            
            // Check if the piece is at the home entrance position
            if (currentPos === homePathEntrancePos) {
                // Piece is at home entrance, move into home path
                const homePathIndex = moves - 1;
                if (homePathIndex < homePaths[color].length) {
                    return boardPath.length + homePathIndex;
                } else if (homePathIndex === homePaths[color].length) {
                    return 'center';
                } else {
                    return null; // Overshoot
                }
            }
            
            // Handle normal board movement with wrapping
            if (newPos >= boardPath.length) {
                newPos = newPos % boardPath.length;
            }
            
            return newPos;
        }

        function addTestResult(testName, passed, details) {
            const resultsDiv = document.getElementById('testResults');
            const resultDiv = document.createElement('div');
            resultDiv.className = passed ? 'test-result test-pass' : 'test-result test-fail';
            resultDiv.innerHTML = `<strong>${testName}:</strong> ${passed ? 'PASS ‚úÖ' : 'FAIL ‚ùå'}<br><small>${details}</small>`;
            resultsDiv.appendChild(resultDiv);
        }

        function runTests() {
            const resultsDiv = document.getElementById('testResults');
            resultsDiv.innerHTML = '<h2>üß™ Actual Bug Discovery</h2>';

            // Test where the REAL bug was happening
            // The bug was in the wrapping logic when newPos >= boardPath.length
            
            // Test cases where pieces go beyond board length
            const testCases = [
                { color: 'green', pos: 50, moves: 10, desc: 'Green piece wrapping around board' },
                { color: 'green', pos: 54, moves: 6, desc: 'Green piece near board end' },
                { color: 'red', pos: 50, moves: 10, desc: 'Red piece wrapping around board' },
                { color: 'red', pos: 54, moves: 6, desc: 'Red piece near board end' },
                { color: 'blue', pos: 50, moves: 10, desc: 'Blue piece wrapping around board' },
                { color: 'yellow', pos: 50, moves: 10, desc: 'Yellow piece wrapping around board' }
            ];

            testCases.forEach(test => {
                const buggyResult = calculateNewPositionBuggy(test.color, test.pos, test.moves);
                const fixedResult = calculateNewPosition(test.color, test.pos, test.moves);
                
                const buggyEntersHome = buggyResult !== null && buggyResult >= boardPath.length;
                const fixedEntersHome = fixedResult !== null && fixedResult >= boardPath.length;
                
                const homeEntrancePos = (startPositions[test.color] + 51) % boardPath.length;
                const shouldEnterHome = test.pos === homeEntrancePos;
                
                const isFixed = (fixedEntersHome === shouldEnterHome);
                
                addTestResult(
                    `${test.desc}`,
                    isFixed,
                    `Position ${test.pos} + ${test.moves} moves. Home entrance: ${homeEntrancePos}. Buggy: ${buggyResult}, Fixed: ${fixedResult}. Should enter home: ${shouldEnterHome}`
                );
            });

            // Now test the specific case from the issue
            const greenEntrancePos = (startPositions.green + 51) % boardPath.length;
            
            addTestResult(
                'Green home entrance position calculation',
                true,
                `Green starts at ${startPositions.green}, home entrance at ${greenEntrancePos}`
            );

            // Test the exact scenario: green piece at position 30 (left side) trying to enter home
            const greenAt30Buggy = calculateNewPositionBuggy('green', 30, 6);
            const greenAt30Fixed = calculateNewPosition('green', 30, 6);
            
            addTestResult(
                'Green piece at position 30 (left side of board)',
                greenAt30Fixed < boardPath.length,
                `Should stay on board. Buggy: ${greenAt30Buggy}, Fixed: ${greenAt30Fixed}`
            );

            // Show the calculation insight
            const insightDiv = document.createElement('div');
            insightDiv.className = 'analysis';
            insightDiv.innerHTML = `
                <h3>üîç Bug Analysis Result</h3>
                <p><strong>The real bug was in the wrapping logic when pieces exceed the board length!</strong></p>
                <p>In the buggy version, when <code>newPos >= boardPath.length</code>, it would incorrectly enter the home path by calculating <code>homePathIndex = newPos - boardPath.length</code>.</p>
                <p>This meant ANY piece that went beyond the board would potentially enter ANY home path, not just their own!</p>
                <p><strong>The fix:</strong> Proper position validation and only allowing home entry from the correct entrance position.</p>
            `;
            resultsDiv.appendChild(insightDiv);
        }

        // Run tests when page loads
        window.addEventListener('load', runTests);
    </script>
</body>
</html>